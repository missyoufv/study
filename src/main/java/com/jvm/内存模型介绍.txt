JMM功能
    这是一种虚拟的规范，作用于工作内存和主存之间数据同步过程。目的是解决由于多线程通过共享内存进行通信时，存在的工作内存数据不一致、编译器会对代码指令重排序、
    处理器会对代码乱序执行等带来的问题。


指令重排
    编译器优化的重排序：
        编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
    指令级并行的重排序：
        现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
    内存系统的重排序：
        处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行

数据依赖跟控制依赖：
    对于数据依赖性跟控制依赖性的代码不会重拍。

        1、数据依赖 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性，这样的代码都不允许重排
           (重排后结果就不一样了)。数据依赖分下列三种类型
                写后读 b=1 a=b
                写后写 b=1 b=3
                读后写 a=b;b=2;

        2、控制依赖 flag变量是个标记，用来标识变量a是否已被写入，在use方法中比变量i依赖if (flag)的判断，这里就叫控制依赖，如果发生了重排序，结果就不对了

            public void use(){
               if(flag){ //A
                  int i = a*a;// B
                  ....
               }
            }

as-if-serial
    不管如何重排序，都必须保证代码在单线程下的运行正确，连单线程下都无法正确，更不用讨论多线程并发的情况，所以就提出了一个as-if-serial的概念，
    as-if-serial语义的意思是：
        不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。
        为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。（强调一下，这里所说的数据
        依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑）但是，如
        果操作之间不存在数据依赖关系，这些操作依然可能被编译器和处理器重排序。

内存屏障
    内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存
    屏障的规则禁止重排序。Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序，从而让程序按我们预想的流程去执行。

    作用：
        保证特定操作的执行顺序。
        影响某些数据（或则是某条指令的执行结果）的内存可见性。


    编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：
        不管什么指令都不能和这条Memory Barrier指令重排序。Memory Barrier所做的另外一件事是强制刷出各种CPU cache，
        如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。

    目前有4种屏障





