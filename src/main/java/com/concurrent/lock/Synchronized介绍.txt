Synchronized简介
    Java中提供了Synchronized实现同步操作
        使用方法：Synchronized方法
                  Synchronized代码块

        对于synchronized代码块而言，javac在编译时，会生成对应的monitorenter和monitorexit指令分别对应synchronized同步块的进入和退出，有两个monitorexit指令的原因是：
        为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的try-finally，在finally中会调用monitorexit命令释放锁。而对于synchronized方法而言，
        javac为其生成了一个ACC_SYNCHRONIZED关键字，在JVM进行方法调用时，发现调用的方法被ACC_SYNCHRONIZED修饰，则会先尝试获得锁。在JVM底层，对于这两种synchronized语义的实现大致相同

    锁的几种形式

        传统的锁（也就是下文要说的重量级锁）依赖于系统的同步函数，在linux上使用mutex互斥锁，最底层实现依赖于futex，这些同步函数都涉及到用户态和内核态的切换、
        进程的上下文切换，成本较高。对于加了synchronized关键字但运行时并没有多线程竞争，或两个线程接近于交替执行的情况，使用传统锁机制无疑效率是会比较低的。
        在JDK 1.6之前,synchronized只有传统的锁机制，因此给开发者留下了synchronized关键字相比于其他同步机制性能不好的印象。
        在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。
        在看这几种锁机制的实现前，我们先来了解下对象头，它是实现多种锁机制的基础。

    Java类的实例对象在内存中存储分为三块区域，分别是对象头、实例数据、对齐填充。

    对象头介绍

        对象头包含两部分，第一部分用于存储对象自身运行时的数据，包括GC分代年龄、哈希码、锁状态、线程持有的锁等数据，这部分的数据长度在32位和64位虚拟机中分别为32位和64位，被称为“Mark Word”。
        对象头的另一部分用于存储对象的类元数据的指针，虚拟机通过这个指针可以知道对象是哪个类的实例。

    实例数据介绍

        实例数据用于存储在程序代码中定义的各种类型的字段内容，也包含从父类继承来的。这部分数据的存储顺序会受到虚拟机分配策略参数和字段在代码中定义的顺序的影响。

    对齐填充

        在HotSpot虚拟机中，对象的大小要求是8字节的整数倍，因为对象头的大小正好是8字节的一倍或两倍，而实例数据部分可能不是8字节的整数倍，所以需要凑齐8字节的整数倍，
        就用到了对齐填充部分，它仅仅是用于占位的作用。


    对象头详解

        synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽
        等于4字节，即32bit。对象头中存储的信息有：mark word（占一带宽）和类型指针（占一带宽）、数组长度（占一带宽,对象为数组类型存在，非数组类型不存在）
        在32位系统上1带宽长度为 = 32bit，64位系统上 1带宽=长度为64bit。

        !!!在JVM中，对象在内存中除了本身的数据外还会有个对象头，对于普通对象而言，其对象头中有两类信息：mark word和类型指针。
        类型指针是指向该对象所属类对象的指针，mark word用于存储对象的HashCode、GC分代年龄、锁状态等信息。在32位系统上mark word长度为32字节，64位系统上长度为64字节。
        为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下：


        Java对象头里的Mark Word里默认存储对象的     HashCode(25bit)、分代年龄(4bit)和 是否偏向锁（1bit）锁标记位(2bit)
                             无锁状态               对象的hashcode    对象分代年龄        0               01


         在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据
                             偏向锁                   线程id   epoch   对象分代年龄       1                01
                             轻量级锁               指向栈中锁记录的指针                                   00
                             重量级锁               指向重量级锁的指针                                     10
                             GC标记                           空                                           11


     锁升级过程介绍
        Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状
        态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高
        获得锁和释放锁的效率。

    !!!为什么要引入偏向锁？
           因为经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，
           为了降低获取锁的代价，才引入的偏向锁。

    偏向锁的升级

    当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头
    中的threadID是否一致，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），
    那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，
    如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。

    偏向锁升级详细过程详解

        线程1当前拥有偏向锁对象,线程2是需要竞争到偏向锁。线程2来竞争锁对象;判断当前对象头是否是偏向锁;
        判断拥有偏向锁的线程1是否还存在;线程1不存在,直接设置偏向锁标识为0(线程1执行完毕后,不会主动去释放偏向锁);
        使用cas替换偏向锁线程ID为线程2,锁不升级，仍为偏向锁;线程1仍然存在,暂停线程1；设置锁标志位为00(变为轻量级锁),偏向锁为0;
        更新mark word，将mark word指向线程1中monitor record的指针;继续执行线程1的代码;锁升级为轻量级锁;
        线程2自旋来获取锁对象;

    偏向锁的取消：

        偏向锁是默认开启的，而且开始时间一般是比应用程序启动慢几秒，如果不想有这个延迟，那么可以使用-XX:BiasedLockingStartUpDelay=0；
        如果不想要偏向锁，那么可以通过-XX:-UseBiasedLocking = false来设置；


    !!!为什么要引入轻量级锁？

        轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，
        因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。

    轻量级锁什么时候升级为重量级锁？

        线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中的存储锁记录的空间（称为DisplacedMarkWord），
        然后使用CAS把对象头中的内容替换为线程1存储的锁记录（DisplacedMarkWord）的地址;如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，
        但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是
        有限制的，比如10次或者100次，如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。
        重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。

    重量级锁
        重量级锁对应的锁标志位是10，存储了指向重量级监视器锁的指针，在Hotspot中，对象的监视器（monitor）锁对象由ObjectMonitor对象实现（C++），其跟同步相关的数据结构如下：


        ObjectMonitor() {
            _count        = 0; //用来记录该对象被线程获取锁的次数
            _waiters      = 0;
            _recursions   = 0; //锁的重入次数
            _owner        = NULL; //指向持有ObjectMonitor对象的线程
            _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
            _WaitSetLock  = 0 ;
            _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
          }
        光看这些数据结构对监视器锁的工作机制还是一头雾水，那么我们首先看一下线程在获取锁的几个状态的转换：


        线程的生命周期存在5个状态，start、running、waiting、blocking和dead

        对于一个synchronized修饰的方法(代码块)来说：

        当多个线程同时访问该方法，那么这些线程会先被放进_EntryList队列，此时线程处于blocking状态
        当一个线程获取到了实例对象的监视器（monitor）锁，那么就可以进入running状态，执行方法，此时，ObjectMonitor对象的_owner指向当前线程，_count加1表示当前对象锁被一个线程获取
        当running状态的线程调用wait()方法，那么当前线程释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为null，_count减1，同时线程进入_WaitSet队列，直到有线程调用notify()方法唤醒该线程，则该线程重新获取monitor对象进入_Owner区
        如果当前线程执行完毕，那么也释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为null，_count减1



    !!!为什么说重量级锁开销大呢
        主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。
        这就是说为什么重量级线程开销很大的。

    五：偏向锁，轻量级锁，重量级锁对比

        锁	                    优点	                                                                                缺点	                                            适用场景
    偏向锁	    加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距	                如果线程间存在锁竞争，会带来额外的锁撤销的消耗	            适用于只有一个线程访问同步块场景
    轻量级锁	竞争的线程不会阻塞，提高了程序的响应速度	                                        如果始终得不到索竞争的线程，使用自旋会消耗CPU	            追求响应速度，同步块执行速度非常快
    重量级锁	线程竞争不使用自旋，不会消耗CPU	                                                            线程阻塞，响应时间缓慢	                            追求吞吐量，同步块执行速度较慢



    总结
    通过上面的分析，我们知道了为什么synchronized关键字为何又深得人心，也知道了锁的演变过程。
    也就是说，synchronized关键字并非一开始就该对象加上重量级锁，也是从偏向锁，轻量级锁，再到重量级锁的过程。
    这个过程也告诉我们，假如我们一开始就知道某个同步代码块的竞争很激烈、很慢的话，那么我们一开始就应该使用重量级锁了，从而省掉一些锁转换的开销。
    讲到这里就大概完了，希望能对你有所帮助


    1、同步方法块

    被括起来的块分别有指令：monitorenter 和 monitorexit

    monitorenter:

    从之前的笔记知道，每个对象都有一个监视器锁(monitor)，当monitor被占用时就会处于锁定状态。线程就是执行monitorenter命令获取monitor锁的。

    　　1、如果monitor的进入数为0，则线程获取锁，并设置monitor的进入数为1

    　　2、如果该线程已经占有该monitor，则进入数+1

    　　3、如果其他线程占有该monitor，则monitor的进入数不为0，则该线程进入阻塞状态，直到monitor为0，重新获取monitor的所有权



    monitorexit:

    执行monitorexit的线程必须是monitor的所有者。

    当执行该命令时，monitor的进入数-1，当monitor的进入数为0，该线程已经不再是该monitor的所有者，其他被这个monitor阻塞的线程可以尝试获取monitor的所有权。



    2、同步方法

    方法中会有个ACC_SYNCHRONIZED标志，调用方法时会检查这个标志，如果被设置了，执行线程先获取monitor，再执行方法代码，再释放monitor，
    同一个monitor在同一个时刻只能由一个线程所有。



