RPC介绍
    全称为Remote Procedure Call，即远程过程调用，它是一个计算机通信协议。它允许像调用本地服务一样调用远程服务。它可以有不同的实现方式。如RMI(远程方法调用)、
    Hessian、Http invoker等。另外，RPC是与语言无关的。

    RPC框架 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）
    RPC框架 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）
    RPC框架 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。

    例如在rpc框架中，客户端在调用sayHi()方法，对于客户端而言调用sayHi()方法就像调用本地方法一样，调用 –>返回。但从其实调用的是服务端中的sayHi()方法，
    RPC屏蔽了底层的实现细节，让调用者无需关注网络通信，数据传输等细节。

二、RPC框架结构

      RPC架构分为三部分：
        1）服务提供者，运行在服务器端，提供服务接口定义与服务实现类。
        2）服务中心，运行在服务器端，负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。
        3）服务消费者，运行在客户端，通过远程代理对象调用远程服务。


      实现从下面几个方面思考：
        1.通信模型：假设通信的为A机器与B机器，A与B之间有通信模型，在Java中一般基于BIO或NIO；。
        2.序列化，将对象名称、方法名称、参数等对象信息进行网络传输需要转换成二进制传输，这里可能需要不同的序列化技术方案。如:protobuf，Arvo等。
        3.服务发现与注册

三、常见RCP框架 原理及性能比较

    RMI(原文链接：https://blog.csdn.net/qq_28081453/article/details/83279066)

    RMI由3个部分构成，第一个是rmiregistry（JDK提供的一个可以独立运行的程序，在bin目录下），第二个是server端的程序，对外提供远程对象，第三个是client端的程序，想要调用远程对象的方法。
    首先，先启动rmiregistry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。
    其次，server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到rmiregistry上并对外暴露一个名称。
    最后，client端通过本地的接口和一个已知的名称（即rmiregistry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMIService那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了。

    Hession




四、心跳机制实现方式
    心跳机制有两种实现方式，一种基于TCP自带的心跳包，TCP的SO_KEEPALIVE选项可以，系统默认的默认跳帧频率为2小时，超过2小时后，本地的TCP
    实现会发送一个数据包给远程的 Socket. 如果远程Socket 没有发回响应, TCP实现就会持续尝试 11 分钟, 直到接收到响应为止。 否则就会自动断开
    Socket连接。但TCP自带的心跳包无法检测比较敏感地知道对方的状态，默认2小时的空闲时间，对于大多数的应用而言太长了。可以手工开启KeepAlive
    功能并设置合理的KeepAlive参数。

    另一种在应用层自己进行实现，基本步骤如下：

        Client使用定时器，不断发送心跳；
        Server收到心跳后，回复一个包；
        Server为每个Client启动超时定时器，如果在指定时间内没有收到Client的心跳包，则Client失效。














