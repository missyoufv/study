package com.base;

/**
 *  原码
 *      原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:
 *          [+1]原 = 0000 0001
 *          [-1]原 = 1000 0001
 *
 *      第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是: [1111 1111 , 0111 1111] [-127 , 127]  1000 0000 = -128
 *  反码
 *
 *      正数的反码是其本身、负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.
 *          [+1] = [00000001]原 = [00000001]反
 *          [-1] = [10000001]原 = [11111110]反
 *
 * 补码
 *      正数的补码就是其本身,负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
 *      [-1] = [10000001]原 = [11111110]反 = [11111111]补
 *
 *  总结：
 *      负数：补码转换为原码:符号位不变,数值位按位取反,末位再加1
 *            原码转换为补码：符号位不变,数值位按位取反,末位再加1
 *      整数：都相同
 *
 * 位运算的运算规则：
 *
 *      1、 左移运算符 (左移运算符<<使指定值的所有位都左移规定的次数)
 *
 *          左移的规则只记住一点：丢弃最高位，0补最低位
 *
 *          如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如对int型移动33位，实际上只移动了33%32=1位。
 *
 *          如果移进高阶位（31或63位），那么该值将变为负值
 *
 * 　　2、 右移运算符 （右移运算符>>使指定值的所有位都右移规定的次数。）
 *
 *          右移的规则只记住一点：符号位不变，左边补上符号位
 *
 * 　　     按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1
 * 　　
 *
 *  与（&）、非（~）、或（|）、异或（^）
 * 　　与：两个操作数中位都为1，结果才为1，否则结果为0
 *     或  两个位只要有一个为1，那么结果就是1，否则就为0
 *     非  如果位为0，结果是1，如果位为1，结果是0
 *     异或 两个操作数的位中，相同则结果为0，不同则结果为1
 */
public class OperationDemo {

    public static void main(String[] args) {

        invoke_is_pow();
    }


    /**
     * 判断是2的n次幂
     */
    private static void invoke_is_pow() {

        int a = 8;
        int b=12;
        int result = a & (a - 1);
        System.out.println(result == 0);
        System.out.println((b & b-1)== 0);
        System.out.println(~1);
    }
}
